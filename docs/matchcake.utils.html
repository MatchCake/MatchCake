

<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>matchcake.utils package &mdash; MatchCake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.min.css" type="text/css" />
  <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/theme.min.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="matchcake.typing package" href="matchcake.typing.html" /> 

</head>

<body>
    <header>
        <div class="container">
            <a class="site-nav-toggle hidden-lg-up"><i class="icon-menu"></i></a>
            <a class="site-title" href="index.html">
                MatchCake
            </a>
        </div>
    </header>


<div class="breadcrumbs-outer hidden-xs-down">
    <div class="container">
        















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="breadcrumbs">
    
      <li><a href="index.html">Docs</a></li>
        
          <li><a href="matchcake.html">matchcake package</a></li>
        
      <li>matchcake.utils package</li>
    
    
      <li class="breadcrumbs-aside">
        
            
            <a href="sources/matchcake.utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>
</div>
    </div>
</div>
    <div class="main-outer">
        <div class="container">
            <div class="row">
                <div class="col-12 col-lg-3 site-nav">
                    
<div role="search">
    <form class="search" action="search.html" method="get">
        <div class="icon-input">
            <input type="text" name="q" placeholder="Search" />
            <span class="icon-search"></span>
        </div>
        <input type="submit" value="Go" class="d-hidden" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
    </form>
</div>
                    <div class="site-nav-tree">
                        
                            
                            
                                <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme.html">MatchCake</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#description">Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#installation">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="readme.html#last-unstable-version">Last unstable version</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme.html#cuda-installation">CUDA installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#quick-usage-preview">Quick Usage Preview</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#tutorials">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#notes">Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#about">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#important-links">Important Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#found-a-bug-or-have-a-feature-request">Found a bug or have a feature request?</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#citation">Citation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="matchcake.html">matchcake package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="matchcake.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="matchcake.html#module-matchcake">Module contents</a></li>
</ul>
</li>
</ul>

                            
                        
                    </div>
                </div>
                <div class="col-12 col-lg-9">
                    <div class="document">
                        
                            
  <section id="matchcake-utils-package">
<h1>matchcake.utils package<a class="headerlink" href="#matchcake-utils-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-matchcake.utils.constants">
<span id="matchcake-utils-constants-module"></span><h2>matchcake.utils.constants module<a class="headerlink" href="#module-matchcake.utils.constants" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-matchcake.utils.cuda">
<span id="matchcake-utils-cuda-module"></span><h2>matchcake.utils.cuda module<a class="headerlink" href="#module-matchcake.utils.cuda" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.cuda.is_cuda_available">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.cuda.</span></span><span class="sig-name descname"><span class="pre">is_cuda_available</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable_warnings</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">throw_error</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#matchcake.utils.cuda.is_cuda_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-matchcake.utils.logm">
<span id="matchcake-utils-logm-module"></span><h2>matchcake.utils.logm module<a class="headerlink" href="#module-matchcake.utils.logm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="matchcake.utils.logm.TorchLogm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matchcake.utils.logm.</span></span><span class="sig-name descname"><span class="pre">TorchLogm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.logm.TorchLogm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>Computes the matrix logarithm of input tensors and supports the computation of gradients
through the operation.</p>
<p>This class implements a custom torch.autograd.Function to compute the
matrix logarithm for square matrices or batches of square matrices. The
forward and backward passes are explicitly defined, utilizing functions
provided by SciPy for numerical stability. This implementation supports real
and complex data types.</p>
<p>See: <a class="reference external" href="https://github.com/pytorch/pytorch/issues/9983#issuecomment-891777620">https://github.com/pytorch/pytorch/issues/9983#issuecomment-891777620</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.logm.TorchLogm.backward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grads</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.logm.TorchLogm.backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#matchcake.utils.logm.TorchLogm.forward" title="matchcake.utils.logm.TorchLogm.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#matchcake.utils.logm.TorchLogm.forward" title="matchcake.utils.logm.TorchLogm.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#matchcake.utils.logm.TorchLogm.backward" title="matchcake.utils.logm.TorchLogm.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#matchcake.utils.logm.TorchLogm.forward" title="matchcake.utils.logm.TorchLogm.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.logm.TorchLogm.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.logm.TorchLogm.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the forward of the custom autograd Function.</p>
<p>This function is to be overridden by all subclasses.
There are two ways to define forward:</p>
<p>Usage 1 (Combined forward and ctx):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<ul class="simple">
<li><p>It must accept a context ctx as the first argument, followed by any
number of arguments (tensors or other types).</p></li>
<li><p>See <span class="xref std std-ref">combining-forward-context</span> for more details</p></li>
</ul>
<p>Usage 2 (Separate forward and ctx):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">setup_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">output</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The forward no longer accepts a ctx argument.</p></li>
<li><p>Instead, you must also override the <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.autograd.Function.setup_context()</span></code>
staticmethod to handle setting up the <code class="docutils literal notranslate"><span class="pre">ctx</span></code> object.
<code class="docutils literal notranslate"><span class="pre">output</span></code> is the output of the forward, <code class="docutils literal notranslate"><span class="pre">inputs</span></code> are a Tuple of inputs
to the forward.</p></li>
<li><p>See <span class="xref std std-ref">extending-autograd</span> for more details</p></li>
</ul>
<p>The context can be used to store arbitrary data that can be then
retrieved during the backward pass. Tensors should not be stored
directly on <cite>ctx</cite> (though this is not currently enforced for
backward compatibility). Instead, tensors should be saved either with
<code class="xref py py-func docutils literal notranslate"><span class="pre">ctx.save_for_backward()</span></code> if they are intended to be used in
<code class="docutils literal notranslate"><span class="pre">backward</span></code> (equivalently, <code class="docutils literal notranslate"><span class="pre">vjp</span></code>) or <code class="xref py py-func docutils literal notranslate"><span class="pre">ctx.save_for_forward()</span></code>
if they are intended to be used for in <code class="docutils literal notranslate"><span class="pre">jvp</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.logm.logm">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.logm.</span></span><span class="sig-name descname"><span class="pre">logm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.logm.logm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix exponential of an array <span class="math notranslate nohighlight">\(\ln{X}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not differentiable with Autograd, as it
relies on the scipy implementation.</p>
</div>
</dd></dl>

</section>
<section id="module-matchcake.utils.majorana">
<span id="matchcake-utils-majorana-module"></span><h2>matchcake.utils.majorana module<a class="headerlink" href="#module-matchcake.utils.majorana" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">MajoranaGetter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for caching the Majorana matrices. The Majorana matrices are computed using the function
<a class="reference internal" href="#matchcake.utils.majorana.get_majorana" title="matchcake.utils.majorana.get_majorana"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_majorana()</span></code></a>. The matrices are cached in a dictionary for faster computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – Number of particles</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call self as a function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter.cache_item">
<span class="sig-name descname"><span class="pre">cache_item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter.cache_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache an item. If the cache is full, the oldest item is removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – The key of the item.</p></li>
<li><p><strong>value</strong> – The value of the item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The removed item.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter.clear_cache">
<span class="sig-name descname"><span class="pre">clear_cache</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matchcake.utils.majorana.MajoranaGetter.majorana_tensor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">majorana_tensor</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span></em><a class="headerlink" href="#matchcake.utils.majorana.MajoranaGetter.majorana_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all Majorana matrices as a stacked tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Majorana tensor or shape (<span class="math notranslate nohighlight">\(2n\)</span>, <span class="math notranslate nohighlight">\(2^n\)</span>, <span class="math notranslate nohighlight">\(2^n\)</span>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>TensorLike</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.majorana.get_majorana">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">get_majorana</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.get_majorana" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Majorana matrix defined as</p>
<div class="math notranslate nohighlight">
\[c_{2k+1} = Z^{\otimes k} \otimes X \otimes I^{\otimes n-k-1}\]</div>
<p>for odd <span class="math notranslate nohighlight">\(i\)</span> and</p>
<div class="math notranslate nohighlight">
\[c_{2k} = Z^{\otimes k} \otimes Y \otimes I^{\otimes n-k-1}\]</div>
<p>for even <span class="math notranslate nohighlight">\(i\)</span>, where <span class="math notranslate nohighlight">\(Z\)</span> is the Pauli Z matrix, <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix, <span class="math notranslate nohighlight">\(X\)</span>
is the Pauli X matrix, <span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product, <span class="math notranslate nohighlight">\(k\)</span> is the index of the Majorana
operator and <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Note<span class="colon">:</span></dt>
<dd class="field-odd"><p>The index <span class="math notranslate nohighlight">\(i\)</span> starts from 0.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – Index of the Majorana operator</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of particles</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Majorana matrix</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.majorana.get_majorana_pair">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">get_majorana_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.get_majorana_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Majorana pair defined as</p>
<div class="math notranslate nohighlight">
\[c_{2k+1} c_{2l+1} = Z^{\otimes k+l} \otimes X \otimes I^{\otimes n-k-l-1}\]</div>
<p>for odd <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> and</p>
<div class="math notranslate nohighlight">
\[c_{2k} c_{2l} = Z^{\otimes k+l} \otimes Y \otimes I^{\otimes n-k-l-1}\]</div>
<p>for even <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, where <span class="math notranslate nohighlight">\(Z\)</span> is the Pauli Z matrix, <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix,
<span class="math notranslate nohighlight">\(X\)</span> is the Pauli X matrix, <span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product, <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(l\)</span> are the
indices of the Majorana operators and <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Note<span class="colon">:</span></dt>
<dd class="field-odd"><p>The indices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> start from 0.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – Index of the first Majorana operator</p></li>
<li><p><strong>j</strong> (<em>int</em>) – Index of the second Majorana operator</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of particles</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Majorana pair</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.majorana.get_majorana_pauli_list">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">get_majorana_pauli_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.majorana.get_majorana_pauli_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of Pauli matrices for the computation of the Majorana operator <span class="math notranslate nohighlight">\(c_i\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[c_{2k+1} = Z^{\otimes k} \otimes X \otimes I^{\otimes n-k-1}\]</div>
<p>for odd <span class="math notranslate nohighlight">\(i\)</span> and</p>
<div class="math notranslate nohighlight">
\[c_{2k} = Z^{\otimes k} \otimes Y \otimes I^{\otimes n-k-1}\]</div>
<p>for even <span class="math notranslate nohighlight">\(i\)</span>, where <span class="math notranslate nohighlight">\(Z\)</span> is the Pauli Z matrix, <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix, <span class="math notranslate nohighlight">\(X\)</span>
is the Pauli X matrix, <span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product, <span class="math notranslate nohighlight">\(k\)</span> is the index of the Majorana
operator and <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – Index of the Majorana operator</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of particles</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of Pauli matrices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.majorana.get_majorana_pauli_string">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">get_majorana_pauli_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">join_char</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'⊗'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.get_majorana_pauli_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.majorana.majorana_to_pauli">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.majorana.</span></span><span class="sig-name descname"><span class="pre">majorana_to_pauli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">PauliWord</span></span></span><a class="headerlink" href="#matchcake.utils.majorana.majorana_to_pauli" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-matchcake.utils.math">
<span id="matchcake-utils-math-module"></span><h2>matchcake.utils.math module<a class="headerlink" href="#module-matchcake.utils.math" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.check_is_unitary">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">check_is_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.check_is_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given tensor is unitary.</p>
<p>A unitary tensor satisfies the property that the product of the tensor and its
Hermitian conjugate (dagger) equals the identity matrix of the same shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Any</em>) – Input tensor to check for unitarity.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the tensor is unitary, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.circuit_matmul">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">circuit_matmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="matchcake.constants.html#matchcake.constants.MatmulDirectionType" title="matchcake.constants.MatmulDirectionType"><span class="pre">MatmulDirectionType</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">MatmulDirectionType.LR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'einsum'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'matmul'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'&#64;'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'&#64;'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.math.circuit_matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a matrix multiplication of two matrices with the given direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_matrix</strong> (<em>Any</em>) – First matrix.</p></li>
<li><p><strong>second_matrix</strong> (<em>Any</em>) – Second matrix.</p></li>
<li><p><strong>direction</strong> (<em>Literal</em><em>[</em><em>&quot;rl&quot;</em><em>, </em><em>&quot;lr&quot;</em><em>]</em>) – Direction of the matrix multiplication. “rl” for right to left and “lr” for left to right.
That means the result will be first_matrix &#64; second_matrix if direction is “rl” and second_matrix &#64; first_matrix</p></li>
<li><p><strong>operator</strong> (<em>Literal</em><em>[</em><em>&quot;einsum&quot;</em><em>, </em><em>&quot;matmul&quot;</em><em>, </em><em>&quot;&#64;&quot;</em><em>]</em>) – Operator to use for the matrix multiplication.
“einsum” for einsum, “matmul” for matmul, “&#64;” for __matmul__.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of the matrix multiplication.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_1d_to_2d_indexes">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_1d_to_2d_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.math.convert_1d_to_2d_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a 1D array of integer indexes to a 2D array of row and column indexes.</p>
<p>This function takes a one-dimensional array of integers representing linear
indexes and converts it into a two-dimensional array of row and column
coordinates. The number of rows in the corresponding 2D space can be specified
explicitly or is inferred as the square root of the number of indexes if not given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indexes</strong> (<em>Iterable</em><em>[</em><em>int</em><em>]</em>) – A 1D iterable of integers specifying the linear indexes
to convert into row and column indexes.</p></li>
<li><p><strong>n_rows</strong> (<em>int</em>) – A positive integer specifying the number of rows
in the 2D coordinate space. If not provided, it defaults to the square root
of the number of indexes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D NumPy array with shape (n_indexes, 2), where each row contains
the row and column indexes corresponding to the input linear index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_2d_to_1d_indexes">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_2d_to_1d_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indexes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.math.convert_2d_to_1d_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert 2D indexes to 1D indexes.</p>
<p>This function transforms a list or array of 2D integer indexes into their equivalent 1D format based
on the number of rows in the target matrix. If the number of rows (<cite>n_rows</cite>) is not provided, it is
calculated automatically based on the maximum row index found in the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indexes</strong> – A list, tuple, or NumPy array of 2D integer indexes. Each index is represented as a
tuple or array of two integers indicating a row and a column.</p></li>
<li><p><strong>n_rows</strong> – Optional integer specifying the number of rows in the target 2D structure. Defaults
to None, in which case it is computed from the input indexes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A NumPy array of 1D indexes corresponding to the provided 2D indexes when flattened
row-major order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_and_cast_like">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_and_cast_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.convert_and_cast_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert and cast the tensor1 to the same type as tensor2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor1</strong> (<em>Any</em>) – Tensor to convert and cast.</p></li>
<li><p><strong>tensor2</strong> (<em>Any</em>) – Tensor to use as a reference.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted and casted tensor1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_and_cast_tensor_from_tensors">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_and_cast_tensor_from_tensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_priorities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'numpy'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'autograd'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'jax'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'tf'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'torch'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('numpy',</span> <span class="pre">'autograd',</span> <span class="pre">'jax',</span> <span class="pre">'tf',</span> <span class="pre">'torch')</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span></span></span><a class="headerlink" href="#matchcake.utils.math.convert_and_cast_tensor_from_tensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert and cast the tensor to the same type as the tensors using the given priorities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<em>TensorLike</em>) – Tensor to convert and cast.</p></li>
<li><p><strong>tensors</strong> (<em>List</em><em>[</em><em>TensorLike</em><em>]</em>) – Tensors to use as a reference.</p></li>
<li><p><strong>cast_priorities</strong> (<em>List</em><em>[</em><em>Literal</em><em>[</em><em>&quot;numpy&quot;</em><em>, </em><em>&quot;autograd&quot;</em><em>, </em><em>&quot;jax&quot;</em><em>, </em><em>&quot;tf&quot;</em><em>, </em><em>&quot;torch&quot;</em><em>]</em><em>]</em>) – Priorities of the casting. Higher the index is, higher the priority.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted and casted tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorLike</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_like_and_cast_to">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_like_and_cast_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.convert_like_and_cast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert and cast the tensor to the same type as the tensor like.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<em>Any</em>) – Tensor to convert and cast.</p></li>
<li><p><strong>like</strong> (<em>Any</em>) – Tensor to use as a reference.</p></li>
<li><p><strong>dtype</strong> (<em>Any</em>) – Data type to cast the tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted and casted tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_tensors_to_same_type">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_tensors_to_same_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_priorities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'numpy'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'autograd'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'jax'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'tf'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'torch'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('numpy',</span> <span class="pre">'autograd',</span> <span class="pre">'jax',</span> <span class="pre">'tf',</span> <span class="pre">'torch')</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.math.convert_tensors_to_same_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the tensors to the same type using the given priorities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>List</em><em>[</em><em>TensorLike</em><em>]</em>) – Tensors to convert and cast.</p></li>
<li><p><strong>cast_priorities</strong> (<em>List</em><em>[</em><em>Literal</em><em>[</em><em>&quot;numpy&quot;</em><em>, </em><em>&quot;autograd&quot;</em><em>, </em><em>&quot;jax&quot;</em><em>, </em><em>&quot;tf&quot;</em><em>, </em><em>&quot;torch&quot;</em><em>]</em><em>]</em>) – Priorities of the casting. Higher the index is, higher the priority.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted and casted tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[TensorLike]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.convert_tensors_to_same_type_and_cast_to">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">convert_tensors_to_same_type_and_cast_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_priorities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'numpy'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'autograd'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'jax'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'tf'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'torch'</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('numpy',</span> <span class="pre">'autograd',</span> <span class="pre">'jax',</span> <span class="pre">'tf',</span> <span class="pre">'torch')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.math.convert_tensors_to_same_type_and_cast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the tensors to the same type using the given priorities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>List</em><em>[</em><em>TensorLike</em><em>]</em>) – Tensors to convert and cast.</p></li>
<li><p><strong>cast_priorities</strong> (<em>List</em><em>[</em><em>Literal</em><em>[</em><em>&quot;numpy&quot;</em><em>, </em><em>&quot;autograd&quot;</em><em>, </em><em>&quot;jax&quot;</em><em>, </em><em>&quot;tf&quot;</em><em>, </em><em>&quot;torch&quot;</em><em>]</em><em>]</em>) – Priorities of the casting. Higher the index is, higher the priority.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted and casted tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[TensorLike]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.dagger">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">dagger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.math.dagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conjugate transpose of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Any</em>) – Input tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Conjugate transpose of the tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.det">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.math.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the determinant of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Any</em>) – Input tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Determinant of the tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.exp_taylor_series">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">exp_taylor_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">18</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.math.exp_taylor_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix exponential using the Taylor series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Any</em>) – input of the exponential.</p></li>
<li><p><strong>terms</strong> (<em>int</em>) – Number of terms in the Taylor series.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The exponential of the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.eye_block_matrix">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">eye_block_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TensorLike</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.eye_block_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a matrix and insert it into a bigger eye matrix like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    I &amp; 0 &amp; 0 \\
    0 &amp; M &amp; 0 \\
    0 &amp; 0 &amp; I
\end{pmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(M\)</span> is the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> – </p></li>
<li><p><strong>n</strong> – </p></li>
<li><p><strong>index</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.eye_like">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">eye_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.eye_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an identity-like tensor following the shape of the provided tensor.</p>
<p>This function creates a tensor with the same shape as the input <cite>tensor</cite>, but
with its two last dimensions set to form an identity matrix (i.e., ones on the
diagonal and zeros elsewhere). The values of the generated tensor will be of
the same type as the input tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Any</em>) – The input tensor of any shape. The two last dimensions are
treated as rows and columns for the identity-like matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of the same shape and type as the input with an identity-like
structure in its two last dimensions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.fermionic_operator_matmul">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">fermionic_operator_matmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="matchcake.constants.html#matchcake.constants.MatmulDirectionType" title="matchcake.constants.MatmulDirectionType"><span class="pre">MatmulDirectionType</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">MatmulDirectionType.RL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'einsum'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'matmul'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'&#64;'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'&#64;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.fermionic_operator_matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a matrix multiplication of two fermionic operator matrices with the given direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_matrix</strong> (<em>Any</em>) – First fermionic operator matrix.</p></li>
<li><p><strong>second_matrix</strong> (<em>Any</em>) – Second fermionic operator matrix.</p></li>
<li><p><strong>direction</strong> (<em>Literal</em><em>[</em><em>&quot;rl&quot;</em><em>, </em><em>&quot;lr&quot;</em><em>]</em>) – Direction of the matrix multiplication. “rl” for right to left and “lr” for left to right.
That means the result will be first_matrix &#64; second_matrix if direction is “rl” and second_matrix &#64; first_matrix
if direction is “lr”.</p></li>
<li><p><strong>operator</strong> (<em>Literal</em><em>[</em><em>&quot;einsum&quot;</em><em>, </em><em>&quot;matmul&quot;</em><em>, </em><em>&quot;&#64;&quot;</em><em>]</em>) – Operator to use for the matrix multiplication.
“einsum” for einsum, “matmul” for matmul, “&#64;” for __matmul__.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of the matrix multiplication.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.matmul">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">matmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'einsum'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'matmul'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'&#64;'</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'&#64;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a matrix multiplication of two matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> (<em>Any</em>) – Left matrix.</p></li>
<li><p><strong>right</strong> (<em>Any</em>) – Right matrix.</p></li>
<li><p><strong>operator</strong> (<em>Literal</em><em>[</em><em>&quot;einsum&quot;</em><em>, </em><em>&quot;matmul&quot;</em><em>, </em><em>&quot;&#64;&quot;</em><em>]</em>) – Operator to use for the matrix multiplication.
“einsum” for einsum, “matmul” for matmul, “&#64;” for __matmul__.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of the matrix multiplication.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.orthonormalize">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">orthonormalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_if_normalize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raises_error</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.math.orthonormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalize the tensor.</p>
<dl class="simple">
<dt>..math::</dt><dd><p>U, S, V = SVD(tensor)
return U &#64; V</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<em>Any</em>) – Input tensor.</p></li>
<li><p><strong>check_if_normalize</strong> (<em>bool</em>) – Whether to check if the tensor is already orthonormalized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Orthonormalized tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.random_index">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">random_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.math.random_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random indices based on provided probabilities along a specified axis.</p>
<p>This function selects random indices according to the given probability
distribution. If the probabilities are not normalized to sum to 1,
they can be optionally normalized before use. It supports generating
a specified number of random indices, either as a scalar value or as
an array of indices, depending on the input parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probs</strong> – An array of probabilities along any given dimension. This
array is expected to be non-negative, and its entries are used as
weights to compute the likelihood of selecting corresponding indices.</p></li>
<li><p><strong>n</strong> – Optional integer specifying the number of random indices to
generate for each vector in <cite>probs</cite>. If not provided, defaults to 1.</p></li>
<li><p><strong>axis</strong> – Integer representing the axis of the <cite>probs</cite> array along
which the random indices are generated. Defaults to -1 (last axis).</p></li>
<li><p><strong>normalize_probs</strong> – Boolean indicating whether to normalize <cite>probs</cite>
along the specified axis to ensure that the entries sum to 1.
Defaults to True.</p></li>
<li><p><strong>eps</strong> – A small float value added to the denominator during
normalization to prevent division by zero. Defaults to 1e-12.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A scalar or an array of randomly selected indices based on the
probabilities provided.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.math.svd">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.math.</span></span><span class="sig-name descname"><span class="pre">svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.math.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the singular value decomposition of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Any</em>) – Input tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Singular value decomposition of the tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[Any, Any, Any]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-matchcake.utils.operators">
<span id="matchcake-utils-operators-module"></span><h2>matchcake.utils.operators module<a class="headerlink" href="#module-matchcake.utils.operators" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.operators.adjoint_generator">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.operators.</span></span><span class="sig-name descname"><span class="pre">adjoint_generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op_iterator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><span class="pre">Operation</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Iterator</span><span class="p"><span class="pre">[</span></span><span class="pre">Operation</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.operators.adjoint_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will reverse the order of the operations in the iterator and return the adjoint operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op_iterator</strong> (<em>Iterable</em><em>[</em><em>qml.operation.Operation</em><em>]</em>) – The iterator of operations.</p></li>
<li><p><strong>kwargs</strong> – Additional keyword arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The iterator of adjoint operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.operators.recursive_2in_operator">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.operators.</span></span><span class="sig-name descname"><span class="pre">recursive_2in_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recursive</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.operators.recursive_2in_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an operator recursively to a list of inputs. The operator must accept two inputs. The inputs are applied
from left to right.</p>
<p># TODO: try to go from left to right and from right to left and compare the performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>Callable</em><em>[</em><em>[</em><em>Any</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>Any</em><em>]</em>) – Operator to apply</p></li>
<li><p><strong>__inputs</strong> (<em>List</em><em>[</em><em>Any</em><em>]</em>) – Inputs to apply the operator to</p></li>
<li><p><strong>recursive</strong> (<em>bool</em>) – If True, apply the operator recursively. If False, apply the operator iteratively using
functools.reduce.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of the operator applied to the inputs</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.operators.recursive_kron">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.operators.</span></span><span class="sig-name descname"><span class="pre">recursive_kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">__inputs:</span> <span class="pre">~typing.List[~typing.Any],</span> <span class="pre">lib=&lt;module</span> <span class="pre">'numpy'</span> <span class="pre">from</span> <span class="pre">'/home/runner/work/MatchCake/MatchCake/.venv/lib/python3.10/site-packages/numpy/__init__.py'&gt;,</span> <span class="pre">recursive:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.operators.recursive_kron" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-matchcake.utils.torch_utils">
<span id="matchcake-utils-torch-utils-module"></span><h2>matchcake.utils.torch_utils module<a class="headerlink" href="#module-matchcake.utils.torch_utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.detach">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.torch_utils.detach" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.to_cpu">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">to_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.torch_utils.to_cpu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.to_cuda">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">to_cuda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.torch_utils.to_cuda" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.to_numpy">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x:</span> <span class="pre">~typing.Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.torch_utils.to_numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.to_tensor">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">to_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dtype</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">torch.float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matchcake.utils.torch_utils.to_tensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.torch_utils.torch_wrap_circular_bounds">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.torch_utils.</span></span><span class="sig-name descname"><span class="pre">torch_wrap_circular_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.torch_utils.torch_wrap_circular_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-matchcake.utils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-matchcake.utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.binary_state_to_state">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">binary_state_to_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.binary_state_to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a binary state to a state. The binary state is binary string of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is
the number of particles. The state is a vector of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>binary_state</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>List</em><em>[</em><em>Union</em><em>[</em><em>int</em><em>, </em><em>bool</em><em>]</em><em>]</em><em>, </em><em>str</em><em>]</em>) – Binary state</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>State</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.binary_string_to_state_number">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">binary_string_to_state_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#matchcake.utils.binary_string_to_state_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a binary string to a state number. The binary string is a string of 0s and 1s. The state number is an
integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>binary_string</strong> (<em>str</em>) – Binary string</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>State number</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.binary_string_to_vector">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">binary_string_to_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ascii'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.binary_string_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a binary string to a vector. The binary string is a string of 0s and 1s. The vector is a vector of
integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binary_string</strong> (<em>str</em>) – Binary string</p></li>
<li><p><strong>encoding</strong> (<em>str</em>) – Encoding of the binary string. Default is ascii.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.camel_case_to_spaced_camel_case">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">camel_case_to_spaced_camel_case</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#matchcake.utils.camel_case_to_spaced_camel_case" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a camel case string to a spaced camel case string. The conversion is done by adding a space before
every capital letter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>__string</strong> (<em>str</em>) – Camel case string</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Spaced camel case string</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.check_if_imag_is_zero">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">check_if_imag_is_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#matchcake.utils.check_if_imag_is_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the imaginary part of a matrix is zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__matrix</strong> – Matrix to check</p></li>
<li><p><strong>eps</strong> – Tolerance for the imaginary part</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the imaginary part is zero, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.decompose_binary_state_into_majorana_indexes">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">decompose_binary_state_into_majorana_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__binary_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.decompose_binary_state_into_majorana_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a state into Majorana operators. The state is decomposed as</p>
<div class="math notranslate nohighlight">
\[|x&gt; = c_{2p_{1}} ... c_{2p_{\ell}} |0&gt;\]</div>
<p>where <span class="math notranslate nohighlight">\(|x&gt;\)</span> is the state, <span class="math notranslate nohighlight">\(c_i\)</span> are the Majorana operators, <span class="math notranslate nohighlight">\(p_i\)</span> are the indices of the
Majorana operators and <span class="math notranslate nohighlight">\(\ell\)</span> is the hamming weight of the state.</p>
<p>Note: The state must be a pure state in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>__binary_state</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>List</em><em>[</em><em>Union</em><em>[</em><em>int</em><em>, </em><em>bool</em><em>]</em><em>]</em><em>, </em><em>str</em><em>]</em>) – Input state as a binary string.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of the Majorana operators</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.decompose_matrix_into_majoranas">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">decompose_matrix_into_majoranas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">majorana_getter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#matchcake.utils.majorana.MajoranaGetter" title="matchcake.utils.majorana.MajoranaGetter"><span class="pre">MajoranaGetter</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.decompose_matrix_into_majoranas" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a matrix into Majorana operators. The matrix is decomposed as</p>
<div class="math notranslate nohighlight">
\[\mathbf{M} = \sum_{i=0}^{2^{n}-1} m_i c_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the matrix, <span class="math notranslate nohighlight">\(m_i\)</span> are the coefficients of the matrix, <span class="math notranslate nohighlight">\(n\)</span> is the number
of particles and <span class="math notranslate nohighlight">\(c_i\)</span> are the Majorana operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__matrix</strong> (<em>np.ndarray</em>) – Input matrix</p></li>
<li><p><strong>majorana_getter</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#matchcake.utils.majorana.MajoranaGetter" title="matchcake.utils.majorana.MajoranaGetter"><em>MajoranaGetter</em></a><em>]</em>) – Majorana getter</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coefficients of the Majorana operators</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.decompose_state_into_majorana_indexes">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">decompose_state_into_majorana_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">sparray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.decompose_state_into_majorana_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a state into Majorana operators. The state is decomposed as</p>
<div class="math notranslate nohighlight">
\[|x&gt; = c_{2p_{1}} ... c_{2p_{\ell}} |0&gt;\]</div>
<p>where <span class="math notranslate nohighlight">\(|x&gt;\)</span> is the state, <span class="math notranslate nohighlight">\(c_i\)</span> are the Majorana operators, <span class="math notranslate nohighlight">\(p_i\)</span> are the indices of the
Majorana operators and <span class="math notranslate nohighlight">\(\ell\)</span> is the hamming weight of the state.</p>
<p>Note: The state must be a pure state in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__state</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>, </em><em>sparse.sparray</em><em>]</em>) – Input state</p></li>
<li><p><strong>n</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Number of particles. Used only if the state is an integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of the Majorana operators</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_4x4_non_interacting_fermionic_hamiltonian_from_params">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_4x4_non_interacting_fermionic_hamiltonian_from_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.get_4x4_non_interacting_fermionic_hamiltonian_from_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the non-interacting fermionic Hamiltonian from the parameters of the Matchgate model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>params</strong> (<a class="reference internal" href="matchcake.matchgate_parameter_sets.html#matchcake.matchgate_parameter_sets.matchgate_params.MatchgateParams" title="matchcake.matchgate_parameter_sets.matchgate_params.MatchgateParams"><em>MatchgateParams</em></a>) – Parameters of the Matchgate model</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Non-interacting fermionic Hamiltonian</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_all_subclasses">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_all_subclasses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_base_cls</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#matchcake.utils.get_all_subclasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the subclasses of a class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__class</strong> (<em>Any</em>) – Class</p></li>
<li><p><strong>include_base_cls</strong> (<em>bool</em>) – Include the base class in the set of subclasses</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Subclasses</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_block_diagonal_matrix">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_block_diagonal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.get_block_diagonal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the special block diagonal matrix of shape (2n x 2n) defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{B} =
\oplus_{j=1}^{n}
\begin{pmatrix}
    1 &amp; i \\
    -i &amp; 1
\end{pmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\oplus\)</span> is the direct sum operator, <span class="math notranslate nohighlight">\(n\)</span> is the number of particles and <span class="math notranslate nohighlight">\(i\)</span> is the
imaginary unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – Number of particles</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Block diagonal matrix of shape (2n x 2n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_eigvals_on_z_basis">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_eigvals_on_z_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_on_failure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options_on_failure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TensorLike</span></span></span><a class="headerlink" href="#matchcake.utils.get_eigvals_on_z_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the eigenvalues of the operator on the Z basis.
At first, the eigenvalues are computed by extracting the diagonal elements of the operator matrix.
If the computation fails, the eigenvalues are computed by calling the <cite>qml.eigvals</cite> function.
The problem with the last one is that we have no guarantee that the eigenvalues are ordered and
based on the Z basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> (<em>qml.Operation</em>) – Operator</p></li>
<li><p><strong>raise_on_failure</strong> (<em>bool</em>) – Raise an exception if the computation fails. Default is False.</p></li>
<li><p><strong>options_on_failure</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – Options to pass to the <cite>qml.eigvals</cite> function if the computation fails.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Eigenvalues of the operator on the Z basis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qml.TensorLike</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_hamming_weight">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_hamming_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#matchcake.utils.get_hamming_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hamming weight of a state. The Hamming weight is defined as the number of non-zero elements in the
state.</p>
<p>The binary state is a one hot vector of shape (2^n,) where n is the number of particles.
The Hamming weight is the number of states in the state [0, 1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<em>np.ndarray</em>) – State of the system</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Hamming weight of the state</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_non_interacting_fermionic_hamiltonian_from_coeffs">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_non_interacting_fermionic_hamiltonian_from_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian_coefficients_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy_offset=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lib=&lt;module</span> <span class="pre">'pennylane.numpy'</span> <span class="pre">from</span> <span class="pre">'/home/runner/work/MatchCake/MatchCake/.venv/lib/python3.10/site-packages/pennylane/numpy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.get_non_interacting_fermionic_hamiltonian_from_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the non-interacting fermionic Hamiltonian from the coefficients of the Majorana operators.</p>
<div class="math notranslate nohighlight">
\[H = -i\sum_{\mu,\nu = 0}^{2n-1} h_{\mu \nu} c_\mu c_\nu + \epsilon \mathbb{I}\]</div>
<p>where <span class="math notranslate nohighlight">\(h_{\mu \nu}\)</span> are the coefficients of the Majorana operators <span class="math notranslate nohighlight">\(c_\mu\)</span> and <span class="math notranslate nohighlight">\(c_\nu\)</span>,
<span class="math notranslate nohighlight">\(n\)</span> is the number of particles, <span class="math notranslate nohighlight">\(\mu\)</span>, <span class="math notranslate nohighlight">\(\nu\)</span> are the indices of the Majorana operators,
<span class="math notranslate nohighlight">\(\epsilon\)</span> is the energy offset and <span class="math notranslate nohighlight">\(\mathbb{I}\)</span> is the identity matrix.</p>
<dl class="simple">
<dt>TODO: optimize the method by changing the sum for a matrix multiplication as <span class="math notranslate nohighlight">\(H = i C^T h C\)</span> where <span class="math notranslate nohighlight">\(C\)</span></dt><dd><p>is the matrix of Majorana operators.</p>
</dd>
</dl>
<p>TODO: use multiprocessing to parallelize the computation of the matrix elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian_coefficients_matrix</strong> (<em>np.ndarray</em>) – Coefficients of the Majorana operators. Must be a square matrix of shape
<span class="math notranslate nohighlight">\((2n, 2n)\)</span>.</p></li>
<li><p><strong>energy_offset</strong> (<em>float</em>) – Energy offset</p></li>
<li><p><strong>lib</strong> – Library to use for the operations</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Non-interacting fermionic Hamiltonian</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_probabilities_from_state">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_probabilities_from_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wires</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.get_probabilities_from_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the probabilities from a state. The probabilities are defined as</p>
<div class="math notranslate nohighlight">
\[p_i = |x_i|^2\]</div>
<p>where <span class="math notranslate nohighlight">\(|x_i&gt;\)</span> is the state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – State of the system</p></li>
<li><p><strong>wires</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Wires to consider</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Probabilities</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.get_unitary_from_hermitian_matrix">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">get_unitary_from_hermitian_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.get_unitary_from_hermitian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the unitary matrix from a Hermitian matrix. The unitary matrix is defined as</p>
<div class="math notranslate nohighlight">
\[U = e^{-iH}\]</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> is the Hermitian matrix and <span class="math notranslate nohighlight">\(i\)</span> is the imaginary unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>np.ndarray</em>) – Hermitian matrix</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Unitary matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.load_backend_lib">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">load_backend_lib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.load_backend_lib" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.make_single_particle_transition_matrix_from_gate">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">make_single_particle_transition_matrix_from_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">majorana_getter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#matchcake.utils.majorana.MajoranaGetter" title="matchcake.utils.majorana.MajoranaGetter"><span class="pre">MajoranaGetter</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="headerlink" href="#matchcake.utils.make_single_particle_transition_matrix_from_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the single particle transition matrix. This matrix is the matrix <span class="math notranslate nohighlight">\(R\)</span> such that</p>
<div class="math notranslate nohighlight">
\[R_{\mu\nu} &amp;= \frac{1}{4} \text{Tr}{\left(U c_\mu U^\dagger\right)c_\nu}\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> is the matchgate and <span class="math notranslate nohighlight">\(c_\mu\)</span> is the <span class="math notranslate nohighlight">\(\mu\)</span>-th Majorana operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Note<span class="colon">:</span></dt>
<dd class="field-odd"><p>This operation is of polynomial complexity only when the number of particles is equal or less than 2
and of exponential complexity otherwise.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>u</strong> – Matchgate matrix of shape (…, 2^n, 2^n)</p></li>
<li><p><strong>majorana_getter</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#matchcake.utils.majorana.MajoranaGetter" title="matchcake.utils.majorana.MajoranaGetter"><em>MajoranaGetter</em></a><em>]</em>) – Majorana getter of n particles</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The single particle transition matrix of shape (…, 2n, 2n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.make_transition_matrix_from_action_matrix">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">make_transition_matrix_from_action_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">action_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.make_transition_matrix_from_action_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the transition matrix from the action matrix. The transition matrix is defined as
<span class="math notranslate nohighlight">\(\mathbf{T}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\mathbf{T}_{i,\nu} = \frac{1}{2} \left( \mathbf{A}^T_{2i-1,\nu} + i \mathbf{A}^T_{2i,\nu} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is the action matrix of shape (2n x 2n), <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is the transition matrix
of shape (n x 2n), <span class="math notranslate nohighlight">\(i\)</span> goes from 1 to <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(\nu\)</span> goes from 1 to <span class="math notranslate nohighlight">\(2n\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>action_matrix</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.make_wires_continuous">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">make_wires_continuous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wires</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Wires</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matchcake.utils.make_wires_continuous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.skew_antisymmetric_vector_to_matrix">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">skew_antisymmetric_vector_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">__vector</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.skew_antisymmetric_vector_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skew-antisymmetric matrix from a vector. The skew-antisymmetric (NxN) matrix is defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A} =
\begin{pmatrix}
    0 &amp; a_0 &amp; a_1 &amp; a_2 &amp; \dots &amp; a_{N-1} \\
    -a_0 &amp; 0 &amp; a_{N} &amp; a_{N+1} &amp; \dots &amp; a_{2N-2} \\
    -a_1 &amp; -a_{N} &amp; 0 &amp; a_{2N} &amp; \dots &amp; a_{3N-3} \\
    -a_2 &amp; -a_{N+1} &amp; -a_{2N} &amp; 0 &amp; \dots &amp; a_{4N-4} \\
    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    -a_{N-1} &amp; -a_{2N-2} &amp; -a_{3N-3} &amp; -a_{4N-4} &amp; \dots &amp; 0
\end{pmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> are the elements of the vector <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> of length <span class="math notranslate nohighlight">\(N(N-1)/2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Note<span class="colon">:</span></dt>
<dd class="field-odd"><p>The length of the vector must be <span class="math notranslate nohighlight">\(N(N-1)/2\)</span> where <span class="math notranslate nohighlight">\((N, N)\)</span> is the shape of the matrix.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>__vector</strong> – Vector of length <span class="math notranslate nohighlight">\(N(N-1)/2\)</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Skew-antisymmetric matrix of shape <span class="math notranslate nohighlight">\((N, N)\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.state_to_binary_state">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">state_to_binary_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">sparray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matchcake.utils.state_to_binary_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a state to a binary state. The binary state is binary string of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is
the number of particles. The state is a vector of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>sparse.sparray</em><em>]</em>) – State. If the state is an integer, the state is assumed to be a pure state in the computational
basis and the number of particles must be specified. If the state is a vector, the number of particles is
inferred from the shape of the vector as <span class="math notranslate nohighlight">\(n = \log_2(\text{len}(\text{state}))\)</span>.</p></li>
<li><p><strong>n</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Number of particles. Used only if the state is an integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Binary state as a binary string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">array([1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">array([1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_state</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">array([0, 0, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matchcake.utils.state_to_binary_string">
<span class="sig-prename descclassname"><span class="pre">matchcake.utils.</span></span><span class="sig-name descname"><span class="pre">state_to_binary_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">sparray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#matchcake.utils.state_to_binary_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a state to a binary state. The binary state is binary string of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is
the number of particles. The state is a vector of length <span class="math notranslate nohighlight">\(2^n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>sparse.sparray</em><em>]</em>) – State. If the state is an integer, the state is assumed to be a pure state in the computational
basis and the number of particles must be specified. If the state is a vector, the number of particles is
inferred from the shape of the vector as <span class="math notranslate nohighlight">\(n = \log_2(\text{len}(\text{state}))\)</span>.</p></li>
<li><p><strong>n</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Number of particles. Used only if the state is an integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Binary state as a binary string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">&#39;00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">&#39;01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">&#39;10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_to_binary_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">&#39;000&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


                        
                    </div>
                </div>
            </div>
        </div>
    </div>    


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
    <script type="text/javascript" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/sphinx_highlight.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="static/js/theme.js"></script>
  
    <div class="footer" role="contentinfo">
        <div class="container">
            &#169; Copyright 2023, Jérémie Gince.
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.2.1.
        </div>
    </div>  

</body>
</html>